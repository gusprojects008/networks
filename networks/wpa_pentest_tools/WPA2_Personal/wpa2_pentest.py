import socket
import struct
import psutil
import subprocess

class colors:
      red = "\033[31m"
      green = "\033[32m"
      blue = "\033[34m"
      cyan = "\033[36m"
      purple = "\033[35m"
      reset = "\033[0m"
      pink = "\033[95m"

      # FORMAT TEXT
      bright = '\033[1m'
      background_green = '\033[32m'
      background_red = '\033[41m'
      blink = '\033[5m'
      sublime = '\033[4m'

      # COLOR + BRIGHT
      sb = f'{bright}{sublime}'
      gb = f'{bright}{green}'
      bb = f'{bright}{blue}'

def show_interfaces_addrs():
    try:
       print()
       address_interfaces = psutil.net_if_addrs()
       for interfaces in address_interfaces:
           for info in address_interfaces.get(interfaces):
               if psutil.AF_LINK in info:
                  print(f"{colors.green}{info.address} => {colors.gb}{interfaces}{colors.reset}")
       print()
    except Exception as error:
           print(f"Error to get interfaces and address );\n{colors.red}{str(error)}{colors.reset}\n")

def set_interface_mode(iface_options):
    if iface_options == 0:
       print()
       interface_to_monitor = input(f"{colors.bright}Type it interface for set monitor mode: {colors.reset}")
       try:
          subprocess.run(['ip', 'link', 'set', interface_to_monitor, 'down'])
          subprocess.run(['iw', 'dev', interface_to_monitor, 'set', 'type', 'monitor'])
          subprocess.run(['ip', 'link', 'set', interface_to_monitor, 'up'])
       except Exception as error:
              print(f"Error to the set {interface_to_monitor} for monitor mode ); {str(error)}")

    elif iface_options == 1:
         print()
         add_interface_monitor = input(f"{colors.bright}Type it the interface wireless, for create a other interface virtual in monitor mode: {colors.reset}")
         try:
            subprocess.run(['iw', 'dev', add_interface_monitor, 'interface', 'add', 'wlan0monitor', 'type', 'monitor'])
            subprocess.run(['ip', 'link', 'set', 'wlan0monitor', 'up'])
         except Exception as error:
                print(f"Error to the create virtual interface in monitor mode ); {colors.red}{str(error)}{colors.reset}")
    else:
        print(f"Type it {colors.red}0{colors.reset} or {colors.green}1{colors.reset}")
    print()
    show_interfaces_addrs()

def return_addresses(interface_network):
    addresses_interface = psutil.net_if_addrs()
    if interface_network in addresses_interface:
       for info in addresses_interface.get(interface_network):
           for address in info:
               if psutil.AF_LINK in info:
                  return info.address
    return None

def mac_for_bytes(mac):
    return bytes(int(byte, 16) for byte in mac.split(':'))

# fill with 0 if the byte have less than 2 digits, and transform into hexadecimal 02x 
def bytes_for_mac(mac):
    return ':'.join(format(byte, '02x') for byte in mac)

def calc_rates(rates):
    list_rates_transmition = []
    for rate in rates:
        # OPERATION: AND BIT BY BIT, (rate binary & value hexadecimal: 0x7f/01111111) * 500 
        value_rate = (rate & 0x7f) * 500
        list_rates_transmition.append(f"{value_rate} Mbps")
    return list_rates_transmition

def idenfify_interface_mode(interface):
    try:
       infomations_iface = subrpocess.run(['iwconfig', interface], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=False)
       if "Mode:monitor" in informations_iface.stdout.decode('utf-8'):
          return True
       else:
           return False
    except Exception as error:
           print(f"Error ): it was not possible identify interface mode... {colors.red}{str(error)}, stderr: {information_iface.stderr}{colors.reset}")
           
# AGROUP ALL PACKETS INFO IN A CLASS packets_info
class InfoPackets:
      # THE FUNCTION __init__ IS INITIALIZED WHEN THE CLASS INITIALIZED, THEN THE FUNCTION RECEIVE INTERFACE VALUE
      # AND self FOR REFENCE THE INSTANCE FROM CLASS AND YOUR VALUES
      def __init__(self, interface):
          self.interface = interface
          self.radiotap_header = struct.pack('!HHH', 0x00, 0x00, 0x0c)
          self.mac_interface = return_addresses(interface)
          self.mac_interface_byte = mac_for_bytes(self.mac_interface)
          self.broadcast_addr = b'\xff\xff\xff\xff\xff\xff'
          self.bssid = b'\xff\xff\xff\xff\xff\xff'
          # THE FRAME CONTROL DATA GOES TO THE DESTINATION ADDRESS FIELD AND WILL ALSO WORK OR DESTINY ADDRESS FIELD COULD IT BE EMPTY
          # THAT ALL THE APS(ACCESS POINTS) WILL UNDERSTAND YOU WANT TO GET NETWORK SSIDs NEARBY   
          self.header_iee802 = struct.pack('!6s6sH', self.broadcast_addr, self.mac_interface_byte, 0x4000)
          self.supported_rates = [0x82, 0x84, 0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c]
          self.bytes_rates = bytes(self.supported_rates)
          self.rates = struct.pack('!BB', 0x01, 0x08) + self.bytes_rates
          self.list_rates_transmission = calc_rates(self.supported_rates)
          self.ssid_field = struct.pack('!BB', 0x00, 0x00) + b''
          self.payload_test = struct.pack('!BBBB', 0x01, 0x02, 0x03, 0x04)

# USING STRUCT FOR UNPACK PACKETS AND YOUR DATA, IN CORRECT FORMAT!
# IT IS NECESSARY TO KNOW WHAT TYPES OF DATA ARE COMING, THEIR ORDER AND POSITION, THEREFORE WE NEED COMMUNICATIONS PROTOCOLS WITH 
# STANDARDS FOR SENDING THE DATA IN ORDER, SO THAT OTHER LOW LEVEL PORGRAMS LIKE THIS ARE ABLE TO PREDICT AND PROPERLY DEAL WITH THE 
# DATA EXPECTED
# HEADER ACCORDINGLY WITH TYPE PACKET

# TYPES PACKET: 0X00/00000000 Association Request, 0x01/00000001 Association Reponse, 0x04/00000100 Probe Request, 0x05/00001001 
# Probe Response,
# 0x0a/00001010 Disassociation, 0x0b/00001011 Authentication, 0x0c/00001100 Deauthentication
# DECODE SHOW PACKETS:

# BIG ENDIAN BYTE ORDER, MEANS THAT MORE SIGNIFICANT BYTE COME FIRST, AND LITTLE ENDIAN ORDER IS WHEN THE BYTE
# LESS SIGNIFICANT BYTE COME FIRST. THIS TWO BYTES ORDER IT HAPPENS BECOUSE THE DIFFERENTS ARCHITECTURES OF
# PROCESSOR

def compress_data(packet):
    return ''.join(format(byte, '02x') for byte in packet)

def show_compress_packet(packet):
    return ' '.join(format(byte, '02x') for byte in packet)

#def decode_packets(packet):
    #data_compress = compress_data(packet)
 #   frame_control = data_compress[]  

def SendPackets(interface_network):
    packets_info = InfoPackets(interface_network)
    packet_deauthentication_probe = packets_info.header_iee802 + packets_info.ssid_field + packets_info.rates
    try:
       print(f"\n{colors.bright}INTERFACE IN OPERATION:{colors.reset} {colors.gb}{interface_network} => {packets_info.mac_interface} OR {packets_info.mac_interface_byte}{colors.reset}")
       print(f"\n{colors.bright}SUPPORTED RATES(DEFAULT): {packets_info.list_rates_transmission} OR {packets_info.bytes_rates}{colors.reset}")
       print(f"\n{colors.gb}PACKAGE SENT =>{colors.reset} {colors.red}{packet_deauthentication_probe}{colors.reset}\n")

       with socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003)) as sock:
            sock.bind((interface_network, 0))
            sock.send(packet_deauthentication_probe)
            #while True:
                  #packet, address = sock.recvfrom(2048)
                  #packet_found = packet
                  #if packet_found:
                     #print(packet_found)
    except Exception as error:
           print(f"A Error occur ); {colors.red}{str(error)}{colors.reset}\n")
           sock.close()

if __name__ == "__main__":
   show_interfaces_addrs()
   config_interfaces = int(input(f"{colors.bright}You want set interface? for monitor mode {colors.gb}(1 or 0){colors.reset}: {colors.reset}"))
   try:
      if config_interfaces == 1:
         show_interfaces_addrs()
         print(f"{colors.green}Type it: {colors.gb}0{colors.reset} {colors.green}to set a interface for monitor mode. {colors.purple}Type it: {colors.gb}1{colors.reset} {colors.purple}for add interface virtual in monitor mode:{colors.reset}\n")
         interface_monitor_option = int(input(f"{colors.green}You want: Set interface for monitor mode or add virtual interface in monitor mode? {colors.gb}1{colors.reset}/{colors.gb}0{colors.reset}: "))
         set_interface_mode(interface_monitor_option)
   except Exception as error:
          print(f"\nError to the set config ): or just option 0 (: {colors.red}{str(error)}{colors.reset}\n")
   print()
   interface = input(f"{colors.bright}Type it MANAGED interface Network for operation: {colors.reset}")
   SendPackets(interface)
